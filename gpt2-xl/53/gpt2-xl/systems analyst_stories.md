Once upon a time, there was a systems analyst named Andrew Semenchuk.

From the day he arrived at his first engineering job in 1990, Semenchuk was a straight shooter. He kept working, even though he occasionally made mistakes – like this one – before giving up on the profession. This attitude didn't last for very long, though.

Semenchuk had an idea that had just popped up on the screen in his team environment: An "assurance" function on the system that would be automatically run on every query generated by the data-tracking tool. "The system could tell me what I needed to know," Semenchuk explained on the conference call. To accomplish this, he chose the SQLite database engine.

Semenchuk's reasoning was simple: SQLite's architecture was heavily optimized for performance for databases of all sizes – it had a very specific size of transaction-per-second limitations. If an engineering database used a database architecture that could only support 500 transactions per second, then Semenchuk's SQLite database could handle at least that many queries.

In other words, Semenchuk made a decision based on a good technical argument rather than some kind of philosophical one, like "this database is an evil database."

The next engineer he had brought on board was John Shinnick, another former database researcher at Google. Shinnick was even more adamant about this new type of SQL because he believed it offered a